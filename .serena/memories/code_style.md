# Code Style & Conventions
- React components are written in TypeScript using functional components, hooks, and React Router route files (e.g., `src/pages/Index.tsx`, `src/pages/TNMAI.tsx`). Heavy sections are split into feature folders (`components/home`, `components/tnm-pro`, etc.) and often lazy-loaded via `React.lazy`/`Suspense`.
- Styling mixes Tailwind utility classes with shadcn/ui primitives plus shared tokens from `src/styles` (e.g., `SPACING`). Theme/variant helpers live in `@/lib/utils` and `components.json`. Avoid inline magic numbers when tokens exist.
- Animations centralize in `src/components/animation` with helpers like `PageTransition`, `useSectionAnimation`, and motion variants; prefer those utilities over hand-rolled Framer Motion configs so that route-level transitions stay consistent and honor `prefers-reduced-motion`.
- State management relies on Zustand stores (e.g., `useAuthStore`, `useAccountStore`) with `persist` middleware. Supabase auth state should flow through store helpers such as `setSession`, `refreshRoles`, and caching maps rather than direct client calls scattered throughout components.
- Localization: use `react-i18next` hooks/`Trans` components, `useLocalizedPath`, `useRTL`, and translation preloaders (`preloadRouteTranslations`, `TranslationErrorBoundary`). Strings belong in namespace JSON; components often render `<Trans>` to mix markup safely.
- Utilities: favor `@/utils/request-cache`, `offline-queue`, `offline-storage`, and logger helpers for API work and background tasks. Trading/AI features often emit analytics eventsâ€”reuse `trackButtonClick` etc.
- Linting: ESLint extends `@eslint/js` + `typescript-eslint` with React Hooks/Refresh plugins. Hooks linting rules are enforced; unused vars/`any` are relaxed per config. tsconfig disables `noImplicitAny`/`strictNullChecks`, so be explicit with types in new code even if not mandated.